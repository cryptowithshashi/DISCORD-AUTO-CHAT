/**
 * botLogic.js
 * Contains the core logic for the Discord bot, translated from Python.
 * Communicates with the TUI via an EventEmitter.
 * Created by crypto with shashi
 */

const fs = require('fs').promises; // Use promises for async file operations
const path = require('path'); // <--- CORRECTED THIS LINE
const EventEmitter = require('events');
const apiClient = require('./apiClient');
require('dotenv').config(); // Load .env variables

// --- Configuration Loading ---
const discordTokens = (process.env.DISCORD_TOKENS || '').split(',').map(t => t.trim()).filter(Boolean);
const googleApiKeys = (process.env.GOOGLE_API_KEYS || '').split(',').map(k => k.trim()).filter(Boolean);
const channelIds = (process.env.CHANNEL_IDS || '').split(',').map(id => id.trim()).filter(Boolean);

// Default settings (can be overridden by .env or potentially a config file/channel-specific settings later)
// NOTE: The original Python script prompted for these per channel.
// For simplicity in this Node.js version, we use global settings from .env
// or defaults here. Modify this section if channel-specific settings are needed.
const config = {
    useGeminiAi: (process.env.USE_GEMINI_AI || 'true').toLowerCase() === 'true',
    promptLanguage: (process.env.PROMPT_LANGUAGE || 'id').toLowerCase(),
    readDelaySeconds: parseInt(process.env.READ_DELAY_SECONDS || '5', 10),
    intervalSeconds: parseInt(process.env.INTERVAL_SECONDS || '60', 10),
    useSlowMode: (process.env.USE_SLOW_MODE || 'true').toLowerCase() === 'true',
    useReply: (process.env.USE_REPLY || 'true').toLowerCase() === 'true',
    deleteMessageDelay: process.env.DELETE_MESSAGE_DELAY === 'null' ? null : parseInt(process.env.DELETE_MESSAGE_DELAY || 'null', 10),
    deleteImmediately: (process.env.DELETE_IMMEDIATELY || 'false').toLowerCase() === 'true',
    infoFilePath: path.join(__dirname, 'info.txt'), // Path to info.txt
    googleApiCooldownSeconds: 24 * 60 * 60, // 24 hours cooldown for rate-limited keys
};

// --- Input Validation ---
if (discordTokens.length === 0) {
    console.error("FATAL ERROR: No Discord tokens found in .env (DISCORD_TOKENS). Exiting.");
    process.exit(1);
}
if (config.useGeminiAi && googleApiKeys.length === 0) {
    console.error("FATAL ERROR: Gemini AI is enabled, but no Google API keys found in .env (GOOGLE_API_KEYS). Exiting.");
    process.exit(1);
}
if (channelIds.length === 0) {
    console.error("FATAL ERROR: No Channel IDs found in .env (CHANNEL_IDS). Exiting.");
    process.exit(1);
}
if (config.promptLanguage !== 'en' && config.promptLanguage !== 'id') {
    console.warn(`Invalid PROMPT_LANGUAGE "${config.promptLanguage}". Defaulting to "id".`);
    config.promptLanguage = 'id';
}


// --- Bot State ---
const processedMessageIds = new Set(); // Tracks processed messages to avoid duplicates
const rateLimitedApiKeys = new Map(); // Tracks rate-limited Google API keys and their cooldown expiry time
let lastGeneratedText = null; // Stores the last text generated by AI to avoid repetition
let infoFileLines = []; // Cache for lines from info.txt
let botInfos = {}; // Store info about each bot account { token: { id, username, discriminator } }
let channelDetails = {}; // Store details about each channel { channelId: { name, guild_name, slowModeDelay } }
let googleApiKeyIndex = 0; // For round-robin key usage

// --- EventEmitter for TUI Communication ---
class BotLogic extends EventEmitter {
    constructor() {
        super();
        this.isRunning = false;
        this.timers = []; // Store interval timers to clear them on stop
    }

    // --- Logging Helper ---
    log(level, message) {
        const timestamp = new Date().toISOString();
        let icon = '‚ÑπÔ∏è';
        if (level === 'SUCCESS') icon = '‚úÖ';
        else if (level === 'ERROR') icon = 'üö®';
        else if (level === 'WARNING') icon = '‚ö†Ô∏è';
        else if (level === 'WAIT') icon = '‚åõ';
        else if (level === 'DEBUG') icon = 'üêû'; // Added for debugging

        const logMessage = `[${timestamp}] ${icon} ${message}`;

        // Emit event for TUI
        this.emit('log', level, logMessage);

        // Also log to console (optional, good for debugging)
        // console.log(logMessage);
    }

    // --- Utility Functions ---

    /**
     * Delays execution for a specified number of milliseconds.
     * @param {number} ms - Milliseconds to wait.
     * @returns {Promise<void>}
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Loads lines from the info.txt file.
     */
    async loadInfoFile() {
        try {
            const data = await fs.readFile(config.infoFilePath, 'utf-8');
            infoFileLines = data.split('\n').map(line => line.trim()).filter(Boolean);
            if (infoFileLines.length === 0) {
                this.log('WARNING', `info.txt file is empty or not found at ${config.infoFilePath}. Fallback messages unavailable.`);
            } else {
                this.log('INFO', `Loaded ${infoFileLines.length} lines from info.txt.`);
            }
        } catch (error) {
            this.log('ERROR', `Failed to read info.txt: ${error.message}. Fallback messages unavailable.`);
            infoFileLines = [];
        }
    }

    /**
     * Gets a random line from the cached info.txt lines.
     * @returns {string} A random message or a default fallback.
     */
    getRandomInfoMessage() {
        if (infoFileLines.length === 0) {
            return "Default fallback message: Bot is active."; // Default if file is empty/missing
        }
        return infoFileLines[Math.floor(Math.random() * infoFileLines.length)];
    }

    /**
     * Selects the next available Google API key, handling rate limits and cooldowns.
     * @returns {string|null} An API key or null if all are on cooldown.
     */
    getNextApiKey() {
        if (googleApiKeys.length === 0) return null;

        const now = Date.now();
        let attempts = 0;

        while (attempts < googleApiKeys.length) {
            const key = googleApiKeys[googleApiKeyIndex];
            const cooldownExpiry = rateLimitedApiKeys.get(key);

            if (!cooldownExpiry || now >= cooldownExpiry) {
                // Key is not rate-limited or cooldown has expired
                if (cooldownExpiry) {
                    rateLimitedApiKeys.delete(key); // Remove from rate limit map
                    this.log('INFO', `Google API Key ${key.substring(0, 5)}... cooldown expired. Re-enabling.`);
                }
                googleApiKeyIndex = (googleApiKeyIndex + 1) % googleApiKeys.length; // Move to next key for next time
                return key;
            }

            // Key is still on cooldown, try the next one
            googleApiKeyIndex = (googleApiKeyIndex + 1) % googleApiKeys.length;
            attempts++;
        }

        // If we loop through all keys and all are on cooldown
        this.log('ERROR', 'All Google API keys are currently rate-limited. Waiting for cooldown.');
        // Find the earliest expiry time to potentially wait for
        let earliestExpiry = Infinity;
        rateLimitedApiKeys.forEach(expiry => {
            earliestExpiry = Math.min(earliestExpiry, expiry);
        });
        const waitTimeMs = earliestExpiry - now;
        if (waitTimeMs > 0) {
             this.log('WAIT', `Next key available in ~${Math.ceil(waitTimeMs / 1000 / 60)} minutes.`);
        }
        return null;
    }

    /**
     * Marks an API key as rate-limited.
     * @param {string} apiKey - The API key that was rate-limited.
     */
    markApiKeyRateLimited(apiKey) {
        const expiryTime = Date.now() + config.googleApiCooldownSeconds * 1000;
        rateLimitedApiKeys.set(apiKey, expiryTime);
        this.log('WARNING', `Google API Key ${apiKey.substring(0, 5)}... marked as rate-limited. Cooldown: ${config.googleApiCooldownSeconds / 3600} hours.`);
    }


    /**
     * Generates a reply, either using Gemini AI or fallback text.
     * Handles API key rotation and rate limiting.
     * @param {string} userMessage - The message to reply to (used by AI).
     * @param {string} channelId - Channel ID for context logging.
     * @returns {Promise<string|null>} The generated reply or null if unable to generate.
     */
    async generateReply(userMessage, channelId) {
        if (config.useGeminiAi) {
            let generatedText = null;
            let attempts = 0;
            const maxAttempts = googleApiKeys.length || 1; // Try each key once if available

            while (attempts < maxAttempts) {
                const apiKey = this.getNextApiKey();
                if (!apiKey) {
                    this.log('ERROR', `[Channel ${channelId}] Cannot generate AI reply: All API keys are rate-limited.`);
                    return null; // All keys are cooling down
                }

                this.log('DEBUG', `[Channel ${channelId}] Attempting AI generation with key ${apiKey.substring(0,5)}...`);
                const result = await apiClient.generateGeminiReply(userMessage, apiKey, config.promptLanguage);

                if (result === 'RATE_LIMITED') {
                    this.markApiKeyRateLimited(apiKey);
                    attempts++;
                    this.log('WAIT', `[Channel ${channelId}] API key rate limited, trying next key (${attempts}/${maxAttempts})...`);
                    await this.delay(1000); // Small delay before trying next key
                    continue; // Try the next key
                } else if (result === null) {
                    // General API error or blocked content, don't retry immediately with same prompt
                    this.log('ERROR', `[Channel ${channelId}] Failed to generate AI reply with key ${apiKey.substring(0,5)}... (Check API logs).`);
                     // Consider if we should try another key here or just fail for this message
                     // For now, we'll fail for this message attempt if a non-rate-limit error occurs.
                     return null;
                } else {
                    // Success
                    if (result === lastGeneratedText) {
                        this.log('WARNING', `[Channel ${channelId}] AI generated the same text as last time. Requesting again...`);
                        // We could potentially add a small modification to the prompt here if needed
                        await this.delay(500); // Small delay before retrying
                        // Retry with the *same* key as it worked, just got duplicate content
                        const retryResult = await apiClient.generateGeminiReply(userMessage, apiKey, config.promptLanguage);
                        if (retryResult && retryResult !== 'RATE_LIMITED' && retryResult !== lastGeneratedText) {
                             generatedText = retryResult;
                        } else {
                            this.log('WARNING', `[Channel ${channelId}] AI retry still resulted in same text or error. Using original.`);
                            generatedText = result; // Use the original duplicate if retry fails
                        }

                    } else {
                         generatedText = result;
                    }

                    lastGeneratedText = generatedText; // Store the successfully generated text
                    return generatedText;
                }
            }
            // If all keys were tried and failed (likely all rate-limited)
             this.log('ERROR', `[Channel ${channelId}] Failed to generate AI reply after trying all available keys.`);
             return null;

        } else {
            // Use fallback message from info.txt
            return this.getRandomInfoMessage();
        }
    }

    /**
     * Processes a single channel: fetches messages, generates replies/sends messages.
     * @param {string} channelId - The ID of the channel to process.
     * @param {string} token - The Discord token to use for this channel.
     * @param {object} botInfo - Information about the bot account ({id, username}).
     */
    async processChannel(channelId, token, botInfo) {
        const channelLogPrefix = `[Channel ${channelId} | Bot: ${botInfo.username}]`;
        this.log('DEBUG', `${channelLogPrefix} Starting processing cycle.`);

        let effectiveDelay = config.intervalSeconds * 1000; // Base delay

        try {
            // --- Get Channel Info (including potential slow mode) ---
            // Cache channel info to avoid repeated API calls unless necessary
            if (!channelDetails[channelId] || config.useSlowMode) {
                 const fetchedChannelInfo = await apiClient.getChannelInfo(channelId, token);
                 if (fetchedChannelInfo) {
                     channelDetails[channelId] = {
                         name: fetchedChannelInfo.name || 'Unknown Channel',
                         guild_name: fetchedChannelInfo.guild_name || 'Unknown Server',
                         slowModeDelay: fetchedChannelInfo.rate_limit_per_user || 0 // Seconds
                     };
                     this.log('INFO', `${channelLogPrefix} Fetched channel info: "${channelDetails[channelId].name}" on "${channelDetails[channelId].guild_name}". Slow mode: ${channelDetails[channelId].slowModeDelay}s.`);
                     this.emit('statusUpdate'); // Update TUI status box
                 } else {
                     this.log('ERROR', `${channelLogPrefix} Failed to get channel info. Skipping cycle.`);
                     return; // Cannot proceed without channel info
                 }
            }

            const currentChannelInfo = channelDetails[channelId];

            // --- Handle Gemini AI Reply Logic ---
            if (config.useGeminiAi) {
                this.log('WAIT', `${channelLogPrefix} Waiting ${config.readDelaySeconds}s before reading messages...`);
                await this.delay(config.readDelaySeconds * 1000);

                this.log('INFO', `${channelLogPrefix} Fetching recent messages...`);
                const messages = await apiClient.fetchMessages(channelId, token);

                if (!messages) {
                    this.log('ERROR', `${channelLogPrefix} Failed to fetch messages. Skipping reply generation.`);
                    return;
                }

                if (messages.length === 0) {
                    this.log('INFO', `${channelLogPrefix} No new messages found.`);
                    return; // Nothing to process
                }

                // Process the *most recent* message that hasn't been processed and isn't from the bot itself
                let messageToProcess = null;
                for (const message of messages) {
                     // Check if message is valid (not bot, not processed, has content or specific types if needed)
                     // Type 8 is thread created - ignore for now. Add other types if needed.
                     const isBotMessage = message.author.id === botInfo.id;
                     const alreadyProcessed = processedMessageIds.has(message.id);
                     const isIgnoredType = message.type === 8; // Example: Ignore thread creation messages

                     if (!isBotMessage && !alreadyProcessed && !isIgnoredType) {
                         // Check if message has actual text content (ignore attachment-only messages for AI)
                         if (message.content && message.content.trim().length > 0) {
                             messageToProcess = message;
                             break; // Found the latest valid message to process
                         } else {
                             this.log('INFO', `${channelLogPrefix} Skipping message ${message.id} (no text content or attachment only).`);
                             processedMessageIds.add(message.id); // Mark as processed to avoid re-checking
                         }
                     } else if (isBotMessage) {
                        // Optional: Mark bot's own messages as processed if needed, though deletion logic handles them
                        // processedMessageIds.add(message.id);
                     } else if (alreadyProcessed) {
                         // this.log('DEBUG', `${channelLogPrefix} Skipping already processed message ${message.id}.`);
                     } else if (isIgnoredType) {
                         this.log('INFO', `${channelLogPrefix} Skipping message ${message.id} (type ${message.type}).`);
                         processedMessageIds.add(message.id);
                     }
                }


                if (messageToProcess) {
                    processedMessageIds.add(messageToProcess.id); // Mark as processed
                    const userMessageContent = messageToProcess.content.trim();
                    this.log('INFO', `${channelLogPrefix} New message from ${messageToProcess.author.username}: "${userMessageContent}"`);

                    // --- Apply Slow Mode Delay (if enabled) ---
                    if (config.useSlowMode && currentChannelInfo.slowModeDelay > 0) {
                        this.log('WAIT', `${channelLogPrefix} Channel slow mode active (${currentChannelInfo.slowModeDelay}s). Waiting...`);
                        await this.delay(currentChannelInfo.slowModeDelay * 1000);
                        // Adjust overall interval delay if slow mode is longer
                        effectiveDelay = Math.max(effectiveDelay, (currentChannelInfo.slowModeDelay + 5) * 1000); // Add buffer
                    }

                    // --- Generate Reply ---
                    this.log('INFO', `${channelLogPrefix} Generating reply...`);
                    const replyText = await this.generateReply(userMessageContent, channelId);

                    if (replyText) {
                        if (replyText.trim().toLowerCase() === userMessageContent.toLowerCase()) {
                             this.log('WARNING', `${channelLogPrefix} Generated reply is identical to the original message. Skipping send.`);
                        } else {
                            // --- Send Reply ---
                            this.log('INFO', `${channelLogPrefix} Sending reply: "${replyText}"`);
                            const replyToId = config.useReply ? messageToProcess.id : null;
                            const sentMessage = await apiClient.sendMessage(channelId, replyText, token, replyToId);

                            if (sentMessage) {
                                this.log('SUCCESS', `${channelLogPrefix} Message sent (ID: ${sentMessage.id}).`);
                                // --- Handle Message Deletion ---
                                if (config.deleteMessageDelay !== null && sentMessage.id) {
                                    if (config.deleteImmediately || config.deleteMessageDelay === 0) {
                                        this.log('WAIT', `${channelLogPrefix} Deleting message ${sentMessage.id} immediately...`);
                                        // No need to await deletion, let it run in background
                                        apiClient.deleteMessage(channelId, sentMessage.id, token)
                                            .then(deleted => {
                                                if (deleted) this.log('SUCCESS', `${channelLogPrefix} Message ${sentMessage.id} deleted.`);
                                                // else: Error already logged by apiClient
                                            });
                                    } else if (config.deleteMessageDelay > 0) {
                                        this.log('WAIT', `${channelLogPrefix} Scheduling message ${sentMessage.id} deletion in ${config.deleteMessageDelay}s...`);
                                        setTimeout(async () => {
                                            this.log('WAIT', `${channelLogPrefix} Deleting message ${sentMessage.id} now...`);
                                            const deleted = await apiClient.deleteMessage(channelId, sentMessage.id, token);
                                            if (deleted) this.log('SUCCESS', `${channelLogPrefix} Message ${sentMessage.id} deleted.`);
                                        }, config.deleteMessageDelay * 1000);
                                    }
                                }
                            } else {
                                this.log('ERROR', `${channelLogPrefix} Failed to send message.`);
                                // Handle potential rate limit error from sending
                                // The apiClient might log specific errors (like 429)
                            }
                        }
                    } else {
                        this.log('WARNING', `${channelLogPrefix} Could not generate a reply for the message.`);
                    }
                } else {
                    this.log('INFO', `${channelLogPrefix} No valid new messages found to reply to.`);
                }

            } else {
                // --- Handle Sending Message from File (Gemini AI Disabled) ---
                this.log('INFO', `${channelLogPrefix} Gemini AI disabled. Sending message from info.txt.`);

                 // --- Apply Slow Mode Delay (if enabled and applicable) ---
                 // Usually less critical here, but can be added if needed
                 if (config.useSlowMode && currentChannelInfo.slowModeDelay > 0) {
                     this.log('WAIT', `${channelLogPrefix} Channel slow mode active (${currentChannelInfo.slowModeDelay}s). Waiting before sending...`);
                     await this.delay(currentChannelInfo.slowModeDelay * 1000);
                     effectiveDelay = Math.max(effectiveDelay, (currentChannelInfo.slowModeDelay + 5) * 1000);
                 }

                const messageText = this.getRandomInfoMessage();
                this.log('INFO', `${channelLogPrefix} Sending message: "${messageText}"`);
                // No reply context when sending from file
                const sentMessage = await apiClient.sendMessage(channelId, messageText, token, null);

                if (sentMessage) {
                    this.log('SUCCESS', `${channelLogPrefix} Message sent (ID: ${sentMessage.id}).`);
                    // --- Handle Message Deletion ---
                     if (config.deleteMessageDelay !== null && sentMessage.id) {
                         if (config.deleteImmediately || config.deleteMessageDelay === 0) {
                             this.log('WAIT', `${channelLogPrefix} Deleting message ${sentMessage.id} immediately...`);
                             apiClient.deleteMessage(channelId, sentMessage.id, token)
                                 .then(deleted => {
                                     if (deleted) this.log('SUCCESS', `${channelLogPrefix} Message ${sentMessage.id} deleted.`);
                                 });
                         } else if (config.deleteMessageDelay > 0) {
                             this.log('WAIT', `${channelLogPrefix} Scheduling message ${sentMessage.id} deletion in ${config.deleteMessageDelay}s...`);
                             setTimeout(async () => {
                                 this.log('WAIT', `${channelLogPrefix} Deleting message ${sentMessage.id} now...`);
                                 const deleted = await apiClient.deleteMessage(channelId, sentMessage.id, token);
                                 if (deleted) this.log('SUCCESS', `${channelLogPrefix} Message ${sentMessage.id} deleted.`);
                             }, config.deleteMessageDelay * 1000);
                         }
                     }
                } else {
                    this.log('ERROR', `${channelLogPrefix} Failed to send message.`);
                }
            }

        } catch (error) {
            this.log('ERROR', `${channelLogPrefix} Unhandled error during processing cycle: ${error.message}\n${error.stack}`);
        } finally {
             // Schedule the next run for this specific channel/token combo
             this.log('WAIT', `${channelLogPrefix} Next check in ${Math.round(effectiveDelay / 1000)}s...`);
             const timerId = setTimeout(() => this.processChannel(channelId, token, botInfo), effectiveDelay);
             // Store timer ID if needed for cleanup on stop
             // this.timers.push(timerId); // Be careful managing this if channels/tokens change dynamically
        }
    }


    /**
     * Initializes bot info, loads files, and starts the processing loops for each channel.
     */
    async start() {
        if (this.isRunning) {
            this.log('WARNING', 'Bot is already running.');
            return;
        }
        this.isRunning = true;
        this.log('INFO', 'Starting Bot Logic...');

        // --- Load info.txt ---
        await this.loadInfoFile();

        // --- Get Bot Account Info ---
        this.log('INFO', 'Fetching bot account details...');
        let activeTokens = 0;
        for (const token of discordTokens) {
            const info = await apiClient.getBotInfo(token);
            if (info) {
                botInfos[token] = {
                    id: info.id,
                    username: info.username,
                    discriminator: info.discriminator,
                    fullUsername: `${info.username}#${info.discriminator}`,
                    tokenRef: token // Keep reference to original token
                };
                this.log('SUCCESS', `Bot Account Loaded: ${botInfos[token].fullUsername} (ID: ${info.id})`);
                activeTokens++;
            } else {
                this.log('ERROR', `Failed to validate token: ${token.substring(0, 5)}... Skipping this token.`);
            }
        }


        if (activeTokens === 0) {
             this.log('FATAL', 'No valid Discord tokens could be loaded. Exiting.');
             this.emit('shutdown'); // Signal TUI to exit
             return;
        }
        this.emit('statusUpdate'); // Update TUI

        // --- Fetch Initial Channel Info & Start Processing Loops ---
        this.log('INFO', `Initializing ${channelIds.length} channel(s)...`);
        let tokenIndex = 0;
        const validTokens = discordTokens.filter(t => botInfos[t]); // Use only tokens that were successfully loaded

        if (validTokens.length === 0) {
             this.log('FATAL', 'No valid Discord tokens available to assign to channels. Exiting.');
             this.emit('shutdown');
             return;
        }


        for (const channelId of channelIds) {
            // Assign valid tokens round-robin to channels
            const token = validTokens[tokenIndex % validTokens.length];
            const botInfo = botInfos[token]; // We know this exists because we filtered
            tokenIndex++;

            // Fetch initial info for the channel (will be cached)
            const fetchedChannelInfo = await apiClient.getChannelInfo(channelId, token);
            if (fetchedChannelInfo) {
                 channelDetails[channelId] = {
                     name: fetchedChannelInfo.name || 'Unknown Channel',
                     guild_name: fetchedChannelInfo.guild_name || 'Unknown Server',
                     slowModeDelay: fetchedChannelInfo.rate_limit_per_user || 0
                 };
                  this.log('SUCCESS', `[Channel ${channelId}] Initialized. Name: "${channelDetails[channelId].name}", Server: "${channelDetails[channelId].guild_name}". Bot: ${botInfo.fullUsername}`);
                 // Start the processing loop for this channel immediately
                 // Use setTimeout to avoid blocking the loop, allowing all channels to start concurrently
                 setTimeout(() => this.processChannel(channelId, token, botInfo), 100); // Start almost immediately
            } else {
                 this.log('ERROR', `[Channel ${channelId}] Failed to get initial info. Bot will not monitor this channel.`);
                 // Add placeholder to channelDetails to indicate failure?
                 channelDetails[channelId] = { name: 'Failed to Initialize', guild_name: 'Error', slowModeDelay: 0, error: true };
            }
             this.emit('statusUpdate'); // Update TUI after each channel init attempt
             await this.delay(500); // Small delay between initializing channels to avoid initial burst of API calls
        }

        this.log('SUCCESS', 'Bot logic initialized and running for configured channels.');
        this.emit('statusUpdate'); // Final status update
    }

    /**
     * Stops all running timers and shuts down the bot logic.
     */
    stop() {
        if (!this.isRunning) {
            return;
        }
        this.log('INFO', 'Stopping bot logic...');
        this.isRunning = false;
        // Clear any stored timers (important if processChannel uses setTimeout recursively)
        // This needs refinement if processChannel schedules itself indefinitely
        // A better approach might be a flag check within processChannel
        this.timers.forEach(timerId => clearTimeout(timerId));
        this.timers = [];
        // Add any other cleanup needed
        this.log('INFO', 'Bot logic stopped.');
        this.emit('shutdown');
    }

    // --- Getters for TUI status ---
    getBotInfos() { return botInfos; }
    getChannelDetails() { return channelDetails; }
    getDiscordTokens() { return discordTokens; } // Returns original list from .env
    getGoogleApiKeys() { return googleApiKeys; }
    getChannelIds() { return channelIds; }
    getRateLimitedKeys() { return rateLimitedApiKeys; }
    isRunningStatus() { return this.isRunning; }

}

module.exports = BotLogic;
